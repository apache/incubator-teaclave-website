"use strict";(self.webpackChunkapache_teaclave_incubating=self.webpackChunkapache_teaclave_incubating||[]).push([[3253],{697:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>u,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"teaclave/docs/builtin-functions","title":"How to Add Built-in Functions","description":"There are several ways to execute user-defined functions in the Teaclave","source":"@site/docs/teaclave/docs/builtin-functions.md","sourceDirName":"teaclave/docs","slug":"/docs/builtin-functions","permalink":"/docs/builtin-functions","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"permalink":"/docs/builtin-functions","slug":"/docs/builtin-functions"},"sidebar":"teaclave_sidebar","previous":{"title":"Function in Python","permalink":"/docs/functions-in-python"},"next":{"title":"Deploying Teaclave on Azure Confidential Computing VM","permalink":"/docs/azure-confidential-computing"}}');var o=t(1085),s=t(1184);const r={permalink:"/docs/builtin-functions",slug:"/docs/builtin-functions"},u="How to Add Built-in Functions",c={},a=[{value:"Implement Built-in Functions in Rust",id:"implement-built-in-functions-in-rust",level:2},{value:"Register Functions in the Executor",id:"register-functions-in-the-executor",level:2},{value:"Invoke Functions with the Client SDK",id:"invoke-functions-with-the-client-sdk",level:2}];function l(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"how-to-add-built-in-functions",children:"How to Add Built-in Functions"})}),"\n",(0,o.jsxs)(n.p,{children:["There are several ways to execute user-defined functions in the Teaclave\nplatform. One simple way is to write Python scripts and register them as functions,\nand the scripts will be executed by the ",(0,o.jsx)(n.em,{children:"MesaPy executor"}),". Another way is to add native\nfunctions as built-in functions, and they will be managed by the ",(0,o.jsx)(n.em,{children:"Built-in executor"}),'.\nCompared to Python scripts, native built-in functions implemented in Rust are\nmemory-safe, have better performance, support more third-party libraries and\ncan be remotely attested as well. In this document, we will guide you through\nhow to add a built-in function to Teaclave step by step with a "private join and\ncompute" example.']}),"\n",(0,o.jsx)(n.p,{children:"In this example, consider several banks have names and balance of their clients.\nThese banks want to compute the total balance of common clients in their private\ndata set without leaking the raw sensitive data to other parties. This is\na perfect usage scenario of the Teaclave platform, and we will provide a\nsolution by implementing a built-in function in Teaclave."}),"\n",(0,o.jsx)(n.h2,{id:"implement-built-in-functions-in-rust",children:"Implement Built-in Functions in Rust"}),"\n",(0,o.jsxs)(n.p,{children:["All built-in functions are implemented in the ",(0,o.jsx)(n.code,{children:"teaclave_function"}),' crate and can\nbe selectively compiled using feature gates. Basically, one built-in function\nneeds two things: a name and a function implementation. Follow the convention of\nother built-in function implementations, we define our "private join and\ncompute" function like this:']}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'#[derive(Default)]\npub struct PrivateJoinAndCompute;\n\nimpl PrivateJoinAndCompute {\n    pub const NAME: &\'static str = "builtin-private-join-and-compute";\n    pub fn new() -> Self {\n        Default::default()\n    }\n    pub fn run(\n        &self,\n        arguments: FunctionArguments,\n        runtime: FunctionRuntime,\n    ) -> Result<String> {\n        ...\n        Ok(summary)\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"NAME"})," is the identifier of a function, which is used for creating tasks.\nUsually, the name of a built-in function starts with the ",(0,o.jsx)(n.code,{children:"built-in"})," prefix. In\naddition, we need to define an entry point of the function, which is the ",(0,o.jsx)(n.code,{children:"run"}),"\nfunction. The ",(0,o.jsx)(n.code,{children:"run"})," function can take arguments (in the ",(0,o.jsx)(n.code,{children:"FunctionAruguments"}),"\ntype) and runtime (in the ",(0,o.jsx)(n.code,{children:"FunctionRuntime"})," type) for interacting with external\nresources (e.g., reading/writing input/output files). Also, the ",(0,o.jsx)(n.code,{children:"run"})," function\ncan return a summary of the function execution."]}),"\n",(0,o.jsxs)(n.p,{children:["Since the function arguments is in the JSON object format and can be easily\ndeserialized to a Rust struct with ",(0,o.jsx)(n.code,{children:"serde_json"}),". Therefore, we define a struct\n",(0,o.jsx)(n.code,{children:"PrivateJoinAndComputeArguments"})," which derive the ",(0,o.jsx)(n.code,{children:"serde::Deserialize"})," trait for\nthe conversion. Then we implement ",(0,o.jsx)(n.code,{children:"TryFrom"})," trait for the struct to convert the\n",(0,o.jsx)(n.code,{children:"FunctionArguments"})," type to the actual ",(0,o.jsx)(n.code,{children:"PrivateJoinAndComputeArguments"})," type."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'#[derive(serde::Deserialize)]\nstruct PrivateJoinAndComputeArguments {\n    num_user: usize, // Number of users in the multiple party computation\n}\n\nimpl TryFrom<FunctionArguments> for PrivateJoinAndComputeArguments {\n    type Error = anyhow::Error;\n\n    fn try_from(arguments: FunctionArguments) -> Result<Self, Self::Error> {\n        use anyhow::Context;\n        serde_json::from_str(&arguments.into_string()).context("Cannot deserialize arguments")\n    }\n}\n\n'})}),"\n",(0,o.jsxs)(n.p,{children:["When executing the function, a ",(0,o.jsx)(n.code,{children:"runtime"})," object will be passed to the function.\nWe can read or write files with the ",(0,o.jsx)(n.code,{children:"runtime"})," with the ",(0,o.jsx)(n.code,{children:"open_input"})," and\n",(0,o.jsx)(n.code,{children:"create_output"})," functions."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:"// Read data from a file\nlet mut input_io = runtime.open_input(&input_file_name)?;\ninput_io.read_to_end(&mut data)?;\n...\n// Write data into a file\nlet mut output = runtime.create_output(&output_file_name)?;\noutput.write_all(&output_bytes)?;\n"})}),"\n",(0,o.jsx)(n.h2,{id:"register-functions-in-the-executor",children:"Register Functions in the Executor"}),"\n",(0,o.jsxs)(n.p,{children:["To use the function, we need to register it to the built-in executor. Please also\nput a ",(0,o.jsx)(n.code,{children:"cfg"})," attribute to make sure developers can conditionally build functions\ninto the executor."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-rust",children:'impl TeaclaveExecutor for BuiltinFunctionExecutor {\n    fn execute(\n        &self,\n        name: String,\n        arguments: FunctionArguments,\n        _payload: String,\n        runtime: FunctionRuntime,\n    ) -> Result<String> {\n        match name.as_str() {\n            ...\n            #[cfg(feature = "builtin_private_join_and_compute")]\n            PrivateJoinAndCompute::NAME => PrivateJoinAndCompute::new().run(arguments, runtime),\n            ...\n        }\n    }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"invoke-functions-with-the-client-sdk",children:"Invoke Functions with the Client SDK"}),"\n",(0,o.jsxs)(n.p,{children:["Finally, we can invoke the function with the client SDK. In our example, we use\nthe Python client SDK. Basically, this process includes registering input/output\nfiles, creating tasks, approving tasks, invoking tasks and getting execution\nresults. You can see more details in the ",(0,o.jsx)(n.code,{children:"examples/python"})," directory."]})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},1184:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>u});var i=t(4041);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function u(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);