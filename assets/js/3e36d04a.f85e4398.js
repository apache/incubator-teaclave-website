"use strict";(self.webpackChunkapache_teaclave_incubating=self.webpackChunkapache_teaclave_incubating||[]).push([[5437],{2109:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>d});const l=JSON.parse('{"id":"teaclave-trustzone-sdk/docs/emulate-and-dev-in-docker","title":"\ud83d\ude80 Quick Start For QEMU Emulation","description":"This guide walks you through building and running QEMU emulation using the","source":"@site/docs/teaclave-trustzone-sdk/docs/emulate-and-dev-in-docker.md","sourceDirName":"teaclave-trustzone-sdk/docs","slug":"/trustzone-sdk-docs/emulate-and-dev-in-docker.md","permalink":"/trustzone-sdk-docs/emulate-and-dev-in-docker.md","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"permalink":"/trustzone-sdk-docs/emulate-and-dev-in-docker.md","slug":"/trustzone-sdk-docs/emulate-and-dev-in-docker.md"},"sidebar":"teaclave-trustzone-sdk_sidebar","next":{"title":"Developing TAs with Rust Standard Library in Docker","permalink":"/trustzone-sdk-docs/emulate-and-dev-in-docker-std.md"}}');var i=t(4848),r=t(8453);const s={permalink:"/trustzone-sdk-docs/emulate-and-dev-in-docker.md",slug:"/trustzone-sdk-docs/emulate-and-dev-in-docker.md"},o="\ud83d\ude80 Quick Start For QEMU Emulation",a={},d=[{value:"1. Pull Development Docker Image",id:"1-pull-development-docker-image",level:2},{value:"2. Build the Hello World Example",id:"2-build-the-hello-world-example",level:2},{value:"3. Make the Artifacts Accessible to the Emulator",id:"3-make-the-artifacts-accessible-to-the-emulator",level:2},{value:"Option 1: Manual Sync via <code>sync_to_emulator</code>",id:"option-1-manual-sync-via-sync_to_emulator",level:4},{value:"Option 2: Integrate sync with TA&#39;s Makefile",id:"option-2-integrate-sync-with-tas-makefile",level:4},{value:"4. Multi-Terminal Execution",id:"4-multi-terminal-execution",level:2},{value:"5. Start the Emulation",id:"5-start-the-emulation",level:2},{value:"6. Iterative Development with Frequent Code Updates and Execution",id:"6-iterative-development-with-frequent-code-updates-and-execution",level:2},{value:"Summary",id:"summary",level:2},{value:"Development Environment Details",id:"development-environment-details",level:3}];function c(e){const n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"-quick-start-for-qemu-emulation",children:"\ud83d\ude80 Quick Start For QEMU Emulation"})}),"\n",(0,i.jsx)(n.p,{children:"This guide walks you through building and running QEMU emulation using the\nTeaclave TrustZone SDK."}),"\n",(0,i.jsx)(n.p,{children:"We provide a Docker image with prebuilt QEMU and OP-TEE images to streamline\nthe entire Trusted Application (TA) development workflow. The image allows\ndevelopers to build TAs and emulate a guest virtual machine (VM) that includes\nboth the Normal World and Secure World environments."}),"\n",(0,i.jsx)(n.h2,{id:"1-pull-development-docker-image",children:"1. Pull Development Docker Image"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Terminal A"})," (Main development terminal):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Pull the pre-built development environment\n$ docker pull teaclave/teaclave-trustzone-emulator-nostd-optee-4.5.0-expand-memory:latest\n\n# Clone the repository\n$ git clone https://github.com/apache/incubator-teaclave-trustzone-sdk.git && \\\n  cd incubator-teaclave-trustzone-sdk\n\n# Launch the development container\n$ docker run -it --rm \\\n  --name teaclave_dev_env \\\n  -v $(pwd):/root/teaclave_sdk_src \\\n  -w /root/teaclave_sdk_src \\\n  teaclave/teaclave-trustzone-emulator-nostd-optee-4.5.0-expand-memory:latest\n"})}),"\n",(0,i.jsx)(n.h2,{id:"2-build-the-hello-world-example",children:"2. Build the Hello World Example"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Still in Terminal A"})," (inside the Docker container):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Build the Hello World example (both CA and TA)\nmake -C examples/hello_world-rs/\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Under the hood, the Makefile builds both the Trusted Application (TA) and the\nHost Application separately. After a successful build, you'll find the\nresulting binaries in the ",(0,i.jsx)(n.code,{children:"hello_world-rs"})," directory:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"TA=ta/target/aarch64-unknown-linux-gnu/release/133af0ca-bdab-11eb-9130-43bf7873bf67.ta\nHOST_APP=host/target/aarch64-unknown-linux-gnu/release/hello_world-rs\n"})}),"\n",(0,i.jsx)(n.h2,{id:"3-make-the-artifacts-accessible-to-the-emulator",children:"3. Make the Artifacts Accessible to the Emulator"}),"\n",(0,i.jsx)(n.p,{children:"After building the Hello World example, the next step is to make the compiled\nartifacts accessible to the emulator."}),"\n",(0,i.jsxs)(n.p,{children:["There are ",(0,i.jsx)(n.strong,{children:"two approaches"})," to do this. You can choose either based on your\npreference:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\ud83d\udce6 ",(0,i.jsx)(n.strong,{children:"Manual sync"}),": Explicitly sync host and TA binaries to the emulator"]}),"\n",(0,i.jsxs)(n.li,{children:["\u2699\ufe0f ",(0,i.jsx)(n.strong,{children:"Makefile integration"}),": Use ",(0,i.jsx)(n.code,{children:"make emulate"})," to build and sync in one step"]}),"\n"]}),"\n",(0,i.jsxs)(n.h4,{id:"option-1-manual-sync-via-sync_to_emulator",children:["Option 1: Manual Sync via ",(0,i.jsx)(n.code,{children:"sync_to_emulator"})]}),"\n",(0,i.jsxs)(n.p,{children:["We provide a helper command called ",(0,i.jsx)(n.code,{children:"sync_to_emulator"}),", which simplifies the\nprocess of syncing the build outputs to the emulation environment.\nRun the following commands inside the container:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"sync_to_emulator --ta $TA\nsync_to_emulator --host $HOST_APP\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Run ",(0,i.jsx)(n.code,{children:"sync_to_emulator -h"})," for more usage options."]}),"\n",(0,i.jsx)(n.h4,{id:"option-2-integrate-sync-with-tas-makefile",children:"Option 2: Integrate sync with TA's Makefile"}),"\n",(0,i.jsxs)(n.p,{children:["For convenience during daily development, the sync invocation can be integrated into\nthe Makefile. In the ",(0,i.jsx)(n.code,{children:"hello_world-rs"})," example, an ",(0,i.jsx)(n.code,{children:"emulate"})," target is provided.\nThis helps automatically build the artifacts and sync them to the emulator in one step:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"make -C examples/hello_world-rs/ emulate\n"})}),"\n",(0,i.jsx)(n.h2,{id:"4-multi-terminal-execution",children:"4. Multi-Terminal Execution"}),"\n",(0,i.jsx)(n.p,{children:"The emulation workflow requires three additional terminals to monitor\nvarious aspects of the system:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Terminal B"}),": \ud83d\udda5\ufe0f ",(0,i.jsx)(n.strong,{children:"Normal World Listener"})," - Provides access to the guest VM shell"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Terminal C"}),": \ud83d\udd12 ",(0,i.jsx)(n.strong,{children:"Secure World Listener"})," - Monitors Trusted Application output logs"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Terminal D"}),": \ud83d\ude80 ",(0,i.jsx)(n.strong,{children:"QEMU Control"})," - Controls the QEMU emulator"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Built-in commands are provided in the Docker image. These commands are located\nin ",(0,i.jsx)(n.code,{children:"/opt/teaclave/bin/"})," and are included in the default user's $PATH."]}),"\n",(0,i.jsxs)(n.p,{children:["You may use ",(0,i.jsx)(n.code,{children:"bash -l"})," or the full path when executing with docker exec."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Terminal B"})," (Guest VM Shell):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Connect to the guest VM shell for running commands inside the emulated environment\n$ docker exec -it teaclave_dev_env bash -l -c listen_on_guest_vm_shell\n\n# Alternative: Use full path\n$ docker exec -it teaclave_dev_env /opt/teaclave/bin/listen_on_guest_vm_shell\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Terminal C"})," (Secure World Output Monitor):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Monitor Trusted Application output logs in real-time\n$ docker exec -it teaclave_dev_env bash -l -c listen_on_secure_world_log\n\n# Alternative: Use full path  \n$ docker exec -it teaclave_dev_env /opt/teaclave/bin/listen_on_secure_world_log\n"})}),"\n",(0,i.jsx)(n.h2,{id:"5-start-the-emulation",children:"5. Start the Emulation"}),"\n",(0,i.jsx)(n.p,{children:"After the listeners are set up, we can start the QEMU emulator."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Terminal D"})," (QEMU Control):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Launch QEMU emulator with debug output and connect to monitoring ports\n$ docker exec -it teaclave_dev_env bash -l -c "LISTEN_MODE=ON start_qemuv8"\n'})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:["\u23f3 ",(0,i.jsx)(n.strong,{children:"Wait for the QEMU environment to fully boot..."}),"\nYou should see boot messages in Terminal D and the guest VM shell prompt\nin Terminal B."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"After QEMU in Terminal D successfully launches, switch to Terminal B, which\nprovides shell access to the guest VM's normal world."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Terminal B"})," (Inside Guest VM):\nFrom this shell, you'll find that the artifacts synced in ",(0,i.jsx)(n.strong,{children:"Step 3"})," are already\navailable in the current working directory. Additionally, the ",(0,i.jsx)(n.code,{children:"ta/"})," and\n",(0,i.jsx)(n.code,{children:"plugin/"})," subdirectories are automatically mounted to be used by TEE OS during\nTA execution and plugin loading."]}),"\n",(0,i.jsxs)(n.p,{children:["For more details on the mount configuration, refer to the\n",(0,i.jsx)(n.code,{children:"listen_on_guest_vm_shell"})," command in the development environment."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# tree\n.\n|-- host\n|   `-- hello_world-rs\n|-- plugin\n`-- ta\n    `-- 133af0ca-bdab-11eb-9130-43bf7873bf67.ta\n\n3 directories, 2 files\n"})}),"\n",(0,i.jsx)(n.p,{children:"This makes it especially convenient for iterative development and frequent code\nupdates."}),"\n",(0,i.jsx)(n.p,{children:"Now we are ready to interact with the TA from normal world shell."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Execute the Hello World Client Application\n$ ./host/hello_world-rs\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The secure world logs, including TA debug messages, are displayed in ",(0,i.jsx)(n.strong,{children:"Terminal C"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"6-iterative-development-with-frequent-code-updates-and-execution",children:"6. Iterative Development with Frequent Code Updates and Execution"}),"\n",(0,i.jsx)(n.p,{children:"During active development and debugging, you can leave Terminals B, C, and D open to\navoid restarting them each time. Simply return to Terminal A, and repeat Step 2 (build)\nand Step 3 (sync) to rebuild and update the artifacts. Once synced, switch to\nTerminal B to re-run the client application. This setup streamlines iterative\ndevelopment and testing."}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.p,{children:"By following this guide, you can emulate and debug Trusted Applications using our\npre-configured Docker-based development environment."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Terminal A"})," serves as the main interface for building and syncing artifacts."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Terminal B"})," gives access to the normal world inside the guest VM, where you\ncan run client applications like the Hello World example."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Terminal C"})," captures logs and debug output from the secure world, making it\neasy to trace TA behavior."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Terminal D"})," controls the QEMU emulator and shows system-level logs during\nboot and runtime."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Together, these terminals provide a complete and efficient workflow for TrustZone\ndevelopment and emulation."}),"\n",(0,i.jsx)(n.h3,{id:"development-environment-details",children:"Development Environment Details"}),"\n",(0,i.jsxs)(n.p,{children:["The setup scripts and built-in commands can be found in ",(0,i.jsx)(n.code,{children:"/opt/teaclave/"}),". Please\nrefer to the Dockerfile in the SDK source repository for more information about\nhow we set up the development environment."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var l=t(6540);const i={},r=l.createContext(i);function s(e){const n=l.useContext(r);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),l.createElement(r.Provider,{value:n},e.children)}}}]);