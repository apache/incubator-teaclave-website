"use strict";(self.webpackChunkapache_teaclave_incubating=self.webpackChunkapache_teaclave_incubating||[]).push([[75],{1184:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>c});var i=n(4041);const s={},r=i.createContext(s);function a(e){const t=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:t},e.children)}},1278:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"teaclave-sgx-sdk/documents/is_x86_feature_detected-in-sgx-sdk","title":"is_x86_feature_detected in Teaclave SGX SDK","description":"Background","source":"@site/docs/teaclave-sgx-sdk/documents/is_x86_feature_detected-in-sgx-sdk.md","sourceDirName":"teaclave-sgx-sdk/documents","slug":"/sgx-sdk-docs/is_x86_feature_detected-in-sgx-sdk","permalink":"/sgx-sdk-docs/is_x86_feature_detected-in-sgx-sdk","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"permalink":"/sgx-sdk-docs/is_x86_feature_detected-in-sgx-sdk","slug":"/sgx-sdk-docs/is_x86_feature_detected-in-sgx-sdk"},"sidebar":"teaclave-sgx-sdk_sidebar","previous":{"title":"Rust SGX Applications in Mesalock Linux","permalink":"/sgx-sdk-docs/sgx_in_mesalock_linux"},"next":{"title":"Developing with Visual Studio Code","permalink":"/sgx-sdk-docs/developing-with-vscode"}}');var s=n(1085),r=n(1184);const a={permalink:"/sgx-sdk-docs/is_x86_feature_detected-in-sgx-sdk",slug:"/sgx-sdk-docs/is_x86_feature_detected-in-sgx-sdk"},c="is_x86_feature_detected in Teaclave SGX SDK",d={},o=[{value:"Background",id:"background",level:2},{value:"Solution",id:"solution",level:2},{value:"Performance concerns",id:"performance-concerns",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsxs)(t.h1,{id:"is_x86_feature_detected-in-teaclave-sgx-sdk",children:[(0,s.jsx)(t.code,{children:"is_x86_feature_detected"})," in Teaclave SGX SDK"]})}),"\n",(0,s.jsx)(t.h2,{id:"background",children:"Background"}),"\n",(0,s.jsxs)(t.p,{children:["Crates often use ",(0,s.jsx)(t.code,{children:"is_x86_feature_detected"})," to select appropriate implementations\n(such as AVX/SSE/SSSE/FMA). It triggers ",(0,s.jsx)(t.code,{children:"cpuid"})," instruction in default ",(0,s.jsx)(t.code,{children:"libstd"}),"\nimplementation on x86_64. We want to avoid such kind of SGX in-compatible\ninstructions and unnecessary AEX events."]}),"\n",(0,s.jsx)(t.h2,{id:"solution",children:"Solution"}),"\n",(0,s.jsx)(t.p,{children:"We found that Intel's SDK initializes its optimized libraries in a way of:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["initialize a global cpu feature indicator by enclave initialization parameter\nin ",(0,s.jsx)(t.a,{href:"https://github.com/intel/linux-sgx/blob/042849cef8db1f0384e52e8cebcd8820c7754398/psw/urts/enclave_creator_hw_com.cpp#L61",children:"urts"})]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c",children:"//Since CPUID instruction is NOT supported within enclave, we enumerate the cpu features here and send to tRTS.\nget_cpu_features(&info.cpu_features);\nget_cpu_features_ext(&info.cpu_features_ext);\ninit_cpuinfo((uint32_t *)info.cpuinfo_table);\n"})}),"\n",(0,s.jsxs)(t.ol,{start:"2",children:["\n",(0,s.jsxs)(t.li,{children:["Initialize optimized libraries according to the global cpu feature indicator\nin ",(0,s.jsx)(t.a,{href:"https://github.com/intel/linux-sgx/blob/042849cef8db1f0384e52e8cebcd8820c7754398/sdk/trts/init_enclave.cpp#L169",children:"trts"})]}),"\n"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c",children:"// optimized libs\nif (SDK_VERSION_2_0 < g_sdk_version || sys_features.size != 0)\n{\n  if (0 != init_optimized_libs(cpu_features, (uint32_t*)sys_features.cpuinfo_table, xfrm))\n  {\n    return -1;\n  }\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["We found that in ",(0,s.jsx)(t.code,{children:"init_optimized_libs"}),", a global variable\n",(0,s.jsx)(t.code,{children:"g_cpu_feature_indicator"})," is initialized to store the ",(0,s.jsx)(t.code,{children:"feature_bit_array"})," which\ncontains everything we need!"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-c",children:"static int set_global_feature_indicator(uint64_t feature_bit_array, uint64_t xfrm) {\n    ......\n    g_cpu_feature_indicator = feature_bit_array;\n    return 0;\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Since Rust SGX SDK depends on trts, we can simply re-use the\n",(0,s.jsx)(t.code,{children:"g_cpu_feature_indicator"})," and simulate the ",(0,s.jsx)(t.code,{children:"is_x86_feature_detected"})," macro\neasily! First we import the value from trts:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'#[link(name = "sgx_trts")]\nextern {\n    static g_cpu_feature_indicator: uint64_t;\n    static EDMM_supported: c_int;\n}\n\n#[inline]\npub fn rsgx_get_cpu_feature() -> u64 {\n    unsafe { g_cpu_feature_indicator }\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Then parse ",(0,s.jsx)(t.code,{children:"g_cpu_feature_indicator"})," like std_detect:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'#[macro_export]\nmacro_rules! is_cpu_feature_supported {\n    ($feature:expr) => ( (($feature & $crate::enclave::rsgx_get_cpu_feature()) != 0) )\n}\n\n#[macro_export]\nmacro_rules! is_x86_feature_detected {\n    ("ia32") => {\n        $crate::cpu_feature::check_for($crate::cpu_feature::Feature::ia32)\n    };\n    ...\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"performance-concerns",children:"Performance concerns"}),"\n",(0,s.jsxs)(t.p,{children:['We observed that some crates (such as matrixmultiply) are likely to use the\nhighest level of instructions for speed up. But it may not be the best solution.\nFor example, the "machine-learning" SGX sample depends on rusty-machine and\nmatrixmultiply, which intend to use AVX instruction if supported. However, if we\nuse the "fallback" mode, it\'ll be about 10x faster than the AVX version. The AVX\noptimiztion is pretty complicated and I have no time to read Intel\'s ',(0,s.jsx)(t.a,{href:"https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-optimization-manual.pdf",children:"Intel\xae 64\nand IA-32 Architectures Optimization Reference\nManual"}),".\nAnd I don't think either of crate's owner or llvm backend can optimize it\nideally. I recommend to choose the appropirate instruction set per workload."]})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);