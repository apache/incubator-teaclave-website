"use strict";(self.webpackChunkapache_teaclave_incubating=self.webpackChunkapache_teaclave_incubating||[]).push([[1620],{7026:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"teaclave-faas-legacy/docs/rust-guideline","title":"Rust Development Guideline","description":"This doc defines some guidelines for developing Teaclave in Rust.","source":"@site/docs/teaclave-faas-legacy/docs/rust-guideline.md","sourceDirName":"teaclave-faas-legacy/docs","slug":"/docs/rust-guildeline","permalink":"/docs/rust-guildeline","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"permalink":"/docs/rust-guildeline","slug":"/docs/rust-guildeline"},"sidebar":"teaclave-faas-legacy_sidebar","previous":{"title":"Development Tips","permalink":"/docs/development-tips"},"next":{"title":"Attestation","permalink":"/docs/codebase/attestation"}}');var i=t(4848),a=t(8453);const r={permalink:"/docs/rust-guildeline",slug:"/docs/rust-guildeline"},l="Rust Development Guideline",o={},d=[{value:"Style",id:"style",level:2},{value:"Elegant APIs",id:"elegant-apis",level:2},{value:"Unsafe Rust",id:"unsafe-rust",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Third-Party Crates",id:"third-party-crates",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"rust-development-guideline",children:"Rust Development Guideline"})}),"\n",(0,i.jsx)(n.p,{children:"This doc defines some guidelines for developing Teaclave in Rust."}),"\n",(0,i.jsx)(n.h2,{id:"style",children:"Style"}),"\n",(0,i.jsxs)(n.p,{children:["We use ",(0,i.jsx)(n.code,{children:"rustfmt"})," and ",(0,i.jsx)(n.code,{children:"clippy"})," to format and lint all Rust code. Mostly, we use\nthe default configurations, but there are a couple of custom settings and lint\nexceptions. The exceptions should be defined along with the code. Our CI will\ncheck the format/lint issues and deny all warnings by default. Simply run ",(0,i.jsx)(n.code,{children:"make format"})," to format all code and ",(0,i.jsx)(n.code,{children:"make CLP=1"})," to lint code before submitting a PR.\nIf you still have some doubts of the ",(0,i.jsx)(n.code,{children:"clippy"})," error, feel free to point out and\nadd an exception."]}),"\n",(0,i.jsx)(n.h2,{id:"elegant-apis",children:"Elegant APIs"}),"\n",(0,i.jsx)(n.p,{children:"Elegantly designed functions and APIs will make the project readable and\nuser-friendly. Basically, we follow naming conventions and API design patterns\nof Rust standard library. There's no official guideline, but here are several\narticles or docs for reference:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://rust-lang.github.io/api-guidelines/",children:"Rust API guidelines"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://github.com/rust-unofficial/patterns",children:"Rust Design Patterns"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://deterministic.space/elegant-apis-in-rust.html#what-makes-an-api-elegant",children:"Elegant Library APIs in Rust"})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"unsafe-rust",children:"Unsafe Rust"}),"\n",(0,i.jsxs)(n.p,{children:["Using unsafe Rust is extremely dangerous, and may break Rust's strong\nmemory-safety guarantees. Therefore, we want to keep unsafe Rust as minimal as\npossible. Sometimes (very rare) using unsafe Rust can significantly improve\nperformance, the unsafe code should be ",(0,i.jsx)(n.em,{children:"well documented"})," and ",(0,i.jsx)(n.em,{children:"explain the\nrationales"}),". For contributors and reviewers, pay attention to the unsafe code\nand carefully check whether the pre-conditions and post-conditions still\nhold."]}),"\n",(0,i.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsxs)(n.p,{children:["Using ",(0,i.jsx)(n.code,{children:"unwrap"})," or ",(0,i.jsx)(n.code,{children:"expect"})," to get a value from an optional type may introduce\nruntime panic. Therefore, properly using the error handling mechanism provided\nby Rust can make the system robust and clean. In some cases, optional value can\nnever be ",(0,i.jsx)(n.code,{children:"None"})," internally, ",(0,i.jsx)(n.code,{children:"unwrap"})," can be used with a comment explaining the\nassumptions and reasons. The same rule also applies to ",(0,i.jsx)(n.code,{children:"panic"})," and similar\nfunctions which may cause runtime panic. One exception is to use ",(0,i.jsx)(n.code,{children:"unwrap"})," and\n",(0,i.jsx)(n.code,{children:"expect"})," in tests, while ",(0,i.jsx)(n.code,{children:"expect"})," is better because it will show a message to\nhelp debugging."]}),"\n",(0,i.jsx)(n.h2,{id:"third-party-crates",children:"Third-Party Crates"}),"\n",(0,i.jsxs)(n.p,{children:["To ensure the security, stability and compatibility of upstream crates, all\nthird-party crates (especially for ported SGX-compatible crates) used in\nTeaclave are vendored in the ",(0,i.jsx)(n.code,{children:"third_party"})," directory. Please refer to the\n",(0,i.jsx)(n.code,{children:"crates-sgx"})," and ",(0,i.jsx)(n.code,{children:"crates-io"})," repo and choose specific versions of vendored\ncrates."]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var s=t(6540);const i={},a=s.createContext(i);function r(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);