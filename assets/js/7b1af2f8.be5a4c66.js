"use strict";(self.webpackChunkapache_teaclave_incubating=self.webpackChunkapache_teaclave_incubating||[]).push([[4588],{1184:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>o});var i=s(4041);const t={},a=i.createContext(t);function r(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(a.Provider,{value:n},e.children)}},3907:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/mesa-7fea936993b9706b89dec552daeedf6f.png"},6391:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"teaclave-sgx-sdk/documents/sgx_in_mesalock_linux","title":"Run Rust SGX Applications in Mesalock Linux","description":"MesaLock Linux is a general purpose Linux distribution which aims to provide a safe and secure user space environment. To eliminate high-severe vulnerabilities caused by memory corruption, the whole user space applications are rewritten in memory-safe programming languages like Rust and Go. This extremely reduces attack surfaces of an operating system exposed in the wild, leaving the remaining attack surfaces auditable and restricted.  Therefore, MesaLock Linux can substantially improve the security of the Linux ecosystem. Additionally, thanks to the Linux kernel, MesaLock Linux supports a broad hardware environment, making it deployable in many places. Two main usage scenarios of MesaLock Linux are for containers and security-sensitive embedded devices. With the growth of the ecosystem, MesaLock Linux would also be adopted in the server environment in the future.","source":"@site/docs/teaclave-sgx-sdk/documents/sgx_in_mesalock_linux.md","sourceDirName":"teaclave-sgx-sdk/documents","slug":"/sgx-sdk-docs/sgx_in_mesalock_linux","permalink":"/sgx-sdk-docs/sgx_in_mesalock_linux","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"permalink":"/sgx-sdk-docs/sgx_in_mesalock_linux","slug":"/sgx-sdk-docs/sgx_in_mesalock_linux"},"sidebar":"teaclave-sgx-sdk_sidebar","previous":{"title":"Setting up your Development Environment","permalink":"/sgx-sdk-docs/environment-setup"},"next":{"title":"`is_x86_feature_detected` in Teaclave SGX SDK","permalink":"/sgx-sdk-docs/is_x86_feature_detected-in-sgx-sdk"}}');var t=s(1085),a=s(1184);const r={permalink:"/sgx-sdk-docs/sgx_in_mesalock_linux",slug:"/sgx-sdk-docs/sgx_in_mesalock_linux"},o="Run Rust SGX Applications in Mesalock Linux",c={},l=[{value:"Is it safe to run Rust SGX applications in Mesalock Linux?",id:"is-it-safe-to-run-rust-sgx-applications-in-mesalock-linux",level:2},{value:"Solution Overview",id:"solution-overview",level:2},{value:"Requirements",id:"requirements",level:2},{value:"Step-by-step Guide",id:"step-by-step-guide",level:2},{value:"mesalock-rt Runtime Details",id:"mesalock-rt-runtime-details",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"run-rust-sgx-applications-in-mesalock-linux",children:"Run Rust SGX Applications in Mesalock Linux"})}),"\n",(0,t.jsx)(n.p,{children:"MesaLock Linux is a general purpose Linux distribution which aims to provide a safe and secure user space environment. To eliminate high-severe vulnerabilities caused by memory corruption, the whole user space applications are rewritten in memory-safe programming languages like Rust and Go. This extremely reduces attack surfaces of an operating system exposed in the wild, leaving the remaining attack surfaces auditable and restricted.  Therefore, MesaLock Linux can substantially improve the security of the Linux ecosystem. Additionally, thanks to the Linux kernel, MesaLock Linux supports a broad hardware environment, making it deployable in many places. Two main usage scenarios of MesaLock Linux are for containers and security-sensitive embedded devices. With the growth of the ecosystem, MesaLock Linux would also be adopted in the server environment in the future."}),"\n",(0,t.jsx)(n.p,{children:"We believe that running Rust SGX applications inside Mesalock Linux could improve the security of SGX applications and reduce their attack surface significantly."}),"\n",(0,t.jsx)(n.h2,{id:"is-it-safe-to-run-rust-sgx-applications-in-mesalock-linux",children:"Is it safe to run Rust SGX applications in Mesalock Linux?"}),"\n",(0,t.jsxs)(n.p,{children:["A typical Rust SGX application has at least to components: one enclave, and one untrusted component. The enclave is self-contained and doesn't need dynamic loading. The untrusted component depends on ",(0,t.jsx)(n.code,{children:"liburts"})," (untrusted runtime service library), which depends on the Application Enclave Services Manager library."]}),"\n",(0,t.jsx)(n.p,{children:"We show the dependency tree as follows. In this tree, we hide all the dynamic libraries which already exist in Mesalock Linux."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"SGX Application\n\u251c\u2500\u2500 Enclave (statically linked)\n\u2514\u2500\u2500 Untrusted component\n    \u2514\u2500\u2500 SGX untrusted runtime (libsgx_urts.so)\n        \u251c\u2500\u2500 libstdc++ (libstdc++.so.6)\n        \u2514\u2500\u2500 AESM service library (libsgx_uae_service.so)\n            \u2514\u2500\u2500 libprotobuf (libprotobuf.so.9)\n                \u251c\u2500\u2500 libstdc++ (libstdc++.so.6)\n                \u2514\u2500\u2500 zlib (libz.so.1)    \n"})}),"\n",(0,t.jsx)(n.p,{children:"We can see that, to support Rust SGX applications in Mesalock Linux, the minimum set of required shared library is : libsgx_urts.so, libsgx_uae_service.so, libstdc++.so.6, libz.so.1 and libprotobuf.so.9."}),"\n",(0,t.jsx)(n.p,{children:"We refined the rules-of-thumb for hybrid memory-safe architecture designing and here is the refined version."}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Unsafe components must not taint safe components, especially for public APIs and data structures."}),"\n",(0,t.jsx)(n.li,{children:"Unsafe components should be as small as possible and decoupled from safe components."}),"\n",(0,t.jsx)(n.li,{children:"Unsafe components should be explicitly marked during deployment and ready to upgrade."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Hence, we believe that running Rust SGX applications in Mesalock Linux could provide better security guarantees if they follow the memory safety principles."}),"\n",(0,t.jsx)(n.h2,{id:"solution-overview",children:"Solution Overview"}),"\n",(0,t.jsx)(n.p,{children:"The whole solution contains two steps:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Build Rust SGX applications in dev environment, such as Rust SGX docker container."}),"\n",(0,t.jsx)(n.li,{children:"Run Rust SGX application in Mesalock Linux docker container."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Step 1 is trivial."}),"\n",(0,t.jsxs)(n.p,{children:["For step 2, the Intel AESM service is required. Technically, Intel AESM service listens at a domain socket ",(0,t.jsx)(n.code,{children:"/var/run/aesmd/aesm.socket"})," and provide service via this domain socket. To interact with CPU, Intel AESM service needs to access ",(0,t.jsx)(n.code,{children:"/dev/isgx"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["There are two options for running the aesm service: (1) start ",(0,t.jsx)(n.code,{children:"aesmd"})," inside the Mesalock Linux container, or (2) start ",(0,t.jsx)(n.code,{children:"aesmd"})," on the host OS and provide service to the SGX application inside the container. The first method provides better isolation for ",(0,t.jsx)(n.code,{children:"aesmd"}),", but it would start a set of infrastructure enclaves for each docker container, wasting the limited EPC memory. The second one only launches one set of infrastructure enclaves for all SGX containers and we believe it is more efficient."]}),"\n",(0,t.jsxs)(n.p,{children:["In our current solution, we put the AESM service process ",(0,t.jsx)(n.code,{children:"aesmd"})," outside the Mesalock Linux docker container and only expose the domain socket ",(0,t.jsx)(n.code,{children:"/var/run/aesm/aesm.socket"})," to the container. In this way, we isolate the AESM service along with the six foundation enclaves (Launch Enclave/Quoting Enclave/Provisioning Enclave/Provisioning Certification Enclave/Platform Service Enclave for long term pairing/Platform Service Enclave for session management) from Mesalock Linux docker container."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"overview",src:s(3907).A+"",width:"2667",height:"1500"})}),"\n",(0,t.jsx)(n.h2,{id:"requirements",children:"Requirements"}),"\n",(0,t.jsx)(n.p,{children:"Rust SGX SDK and docker"}),"\n",(0,t.jsx)(n.h2,{id:"step-by-step-guide",children:"Step-by-step Guide"}),"\n",(0,t.jsx)(n.p,{children:"Step 1 : build SGX application in Rust SGX dev docker container."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ git pull git@github.com:apache/teaclave-sgx-sdk.git\n$ docker run -v /path/to/rust-sgx-sdk:/root/sgx -ti --device /dev/isgx baiduxlab/sgx-rust\n"})}),"\n",(0,t.jsx)(n.p,{children:"In the Rust SGX dev docker container:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ cd /root/sgx/samplecode/hello-rust\n$ make\n...(ignored many lines)...\n</EnclaveConfiguration>\ntcs_num 1, tcs_max_num 1, tcs_min_pool 1\nThe required memory is 1732608B.\nSucceed.\nSIGN =>  bin/enclave.signed.so\n$ exit\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Now the ",(0,t.jsx)(n.code,{children:"hello-rust"})," sample has been compiled successfully."]}),"\n",(0,t.jsx)(n.p,{children:"Step 2 : run SGX application in Mesalock Linux docker container"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"$ docker run --rm -ti \\\n             --device /dev/isgx \\                               # forward isgx device\n             -v /path/to/rust-sgx-sdk:/root/sgx \\               # add SDK\n             -v /path/to/rust-sgx-sdk/mesalock-rt:/opt/sgxrt \\  # add runtime lib\n             -v /var/run/aesmd:/var/run/aesmd \\                 # forward domain socket\n             -e LD_LIBRARY_PATH=/opt/sgxrt \\                    # set lib path\n             -w /root/sgx/samplecode/hello-rust/bin \\           # set working dir\n             mesalocklinux/mesalock-linux\n"})}),"\n",(0,t.jsx)(n.p,{children:"Now the Mesalock Linux docker container has been initiated using method (2) and an Ion shell has been launched. In the container, we execute:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:":/root/sgx/samplecode/hello-rust/bin$ ./app\n[+] Home dir is /root\n[-] Open token file /root/enclave.token error! Will create one.\n[+] Saved updated launch token!\n[+] Init Enclave Successful 2!\nThis is a normal world string passed into Enclave!\nThis is a in-Enclave Rust string!\n[+] say_something success...\n"})}),"\n",(0,t.jsx)(n.h2,{id:"mesalock-rt-runtime-details",children:"mesalock-rt Runtime Details"}),"\n",(0,t.jsx)(n.p,{children:"All these runtime shared libraries come from official releases, including Intel SGX SDK v2.0 release and Ubuntu 16.04 package archive."}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"File"}),(0,t.jsx)(n.th,{children:"Size"}),(0,t.jsx)(n.th,{children:"SHA256"}),(0,t.jsx)(n.th,{children:"Comes from"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"libprotobuf.so.9"}),(0,t.jsx)(n.td,{children:"1170328"}),(0,t.jsx)(n.td,{children:"abd8b868f0f06584c30edbee90e27e2f8546ffe5bbe938922f62c5821b243925"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"http://archive.ubuntu.com/ubuntu/pool/main/p/protobuf/libprotobuf9v5_2.6.1-1.3_amd64.deb",children:"libprotobuf9v5_2.6.1-1.3_amd64.deb"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"libsgx_uae_service.so"}),(0,t.jsx)(n.td,{children:"359944"}),(0,t.jsx)(n.td,{children:"67de93140307268871eb0e00ade9fc800bf3f45371b68ac79157c71b454edbaa"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"https://download.01.org/intel-sgx/linux-2.0/sgx_linux_ubuntu16.04.1_x64_psw_2.0.100.40950.bin",children:"sgx_linux_ubuntu16.04.1_x64_psw_2.0.100.40950.bin"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"libsgx_urts.so"}),(0,t.jsx)(n.td,{children:"166376"}),(0,t.jsx)(n.td,{children:"05a15c27432bded48b49b98f94649b4e90abaedbb4ce8f3c44baa1ff5ce2493d"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"https://download.01.org/intel-sgx/linux-2.0/sgx_linux_ubuntu16.04.1_x64_psw_2.0.100.40950.bin",children:"sgx_linux_ubuntu16.04.1_x64_psw_2.0.100.40950.bin"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"libstdc++.so.6"}),(0,t.jsx)(n.td,{children:"1594800"}),(0,t.jsx)(n.td,{children:"5e68ec758e36fb2db90f6be673cf4112d144a2f29ba400cd5c6e0c8e56ad9408"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"https://launchpad.net/~ubuntu-toolchain-r/+archive/ubuntu/test/+files/libstdc++6_7.2.0-1ubuntu1~16.04_amd64.deb",children:"libstdc++6_7.2.0-1ubuntu1~16.04_amd64.deb"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"libz.so.1"}),(0,t.jsx)(n.td,{children:"104864"}),(0,t.jsx)(n.td,{children:"a04cab74df9c7f96f82b34286bda5d4ee810feaac92dd2e8bcfe931d9c8baef4"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"http://us.archive.ubuntu.com/ubuntu/pool/main/z/zlib/zlib1g_1.2.11.dfsg-0ubuntu1_amd64.deb",children:"zlib1g_1.2.11.dfsg-0ubuntu1_amd64.deb"})})]})]})]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);