"use strict";(self.webpackChunkapache_teaclave_incubating=self.webpackChunkapache_teaclave_incubating||[]).push([[1738],{537:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>c,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"teaclave-faas-legacy/docs/adding-executors","title":"Adding Executors","description":"Teaclave supports several function executors currently: builtin, mesapy and","source":"@site/docs/teaclave-faas-legacy/docs/adding-executors.md","sourceDirName":"teaclave-faas-legacy/docs","slug":"/docs/adding-executors","permalink":"/docs/adding-executors","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"permalink":"/docs/adding-executors","slug":"/docs/adding-executors"},"sidebar":"teaclave-faas-legacy_sidebar","previous":{"title":"Teaclave Service Internals","permalink":"/docs/service-internals"},"next":{"title":"Papers, Talks, and Related Articles","permalink":"/docs/papers-talks"}}');var i=t(4848),s=t(8453);const c={permalink:"/docs/adding-executors",slug:"/docs/adding-executors"},o="Adding Executors",a={},d=[{value:"Steps of Adding a New Executor",id:"steps-of-adding-a-new-executor",level:2},{value:"Linking Related Libraries",id:"linking-related-libraries",level:3},{value:"Invoking the New Executor",id:"invoking-the-new-executor",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"adding-executors",children:"Adding Executors"})}),"\n",(0,i.jsxs)(n.p,{children:["Teaclave supports several function executors currently: ",(0,i.jsx)(n.code,{children:"builtin"}),", ",(0,i.jsx)(n.code,{children:"mesapy"})," and\n",(0,i.jsx)(n.code,{children:"wamr"})," (WebAssembly Micro Runtime). For more information about current function\nexecutors, please check ",(0,i.jsx)(n.a,{href:"/docs/codebase/executor",children:"this link"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"However, sometimes platform providers may found current executors built in\nTeaclave are not applicable for hosting some services, and they want to use\ntheir own executor or an executor shipped by the third-party to execute their\ncode (for example, written languages other than Python or WASM). They can then\nmodify Teaclave's source code to add a customized executor to run their\nfunctions."}),"\n",(0,i.jsx)(n.h2,{id:"steps-of-adding-a-new-executor",children:"Steps of Adding a New Executor"}),"\n",(0,i.jsxs)(n.p,{children:["Executors can be either linked to Teaclave as a third-party library (e.g. Mesapy\nexecutor) or built in Teaclave itself (e.g. builtin executor). The source code\nof either type is located at ",(0,i.jsx)(n.code,{children:"executor/src/"}),". The general steps for adding a\ncustom executor can be summarized in the following steps:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["Create a public executor unit struct and implement the ",(0,i.jsx)(n.code,{children:"TeaclaveExecutor"})," trait."]}),"\n",(0,i.jsxs)(n.li,{children:["Re-export your new executor in ",(0,i.jsx)(n.code,{children:"executor/src/lib.rs"})," to make it callable."]}),"\n",(0,i.jsxs)(n.li,{children:["Add enums in ",(0,i.jsx)(n.code,{children:"ExecutorType"})," and ",(0,i.jsx)(n.code,{children:"Executor"})," (in ",(0,i.jsx)(n.code,{children:"types/src/worker.rs"}),"), as\nwell as corresponding logics for handling the added enums."]}),"\n",(0,i.jsxs)(n.li,{children:["Import and register the added executor in ",(0,i.jsx)(n.code,{children:"worker/src/worker.rs"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"(Optional) Add unit test to your customized executor"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"linking-related-libraries",children:"Linking Related Libraries"}),"\n",(0,i.jsxs)(n.p,{children:["If the custom executor is embedded or ported to Teaclave, ",(0,i.jsx)(n.code,{children:"extern"})," functions\nmight be introduced into Teaclave and thus you also need to tell the build\nsystem where to find the library containing these external functions. You may\nadd this library in the linking command at script\n",(0,i.jsx)(n.code,{children:"cmake/scripts/sgx_link_sign.sh"}),". The linker will try to find the library in\n",(0,i.jsx)(n.code,{children:"${TEACLAVE_OUT_DIR}"}),", which is be parsed to ",(0,i.jsx)(n.code,{children:"build/intermediate"})," in build\nphase. Besides, you can also add several lines to generate or download the\nlibrary in ",(0,i.jsx)(n.code,{children:"CMakeList.txt"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"invoking-the-new-executor",children:"Invoking the New Executor"}),"\n",(0,i.jsxs)(n.p,{children:["Just call the API and remember to set ",(0,i.jsx)(n.code,{children:"executor_type"})," to your new executor\ntype's name (the string used in ",(0,i.jsx)(n.code,{children:"ExecutorType::try_from"})," match case) when\ncalling ",(0,i.jsx)(n.code,{children:"register_function"}),", and set the ",(0,i.jsx)(n.code,{children:"executor"})," to the executor's name\ncorrespondingly."]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>o});var r=t(6540);const i={},s=r.createContext(i);function c(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);