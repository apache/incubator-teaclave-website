"use strict";(self.webpackChunkapache_teaclave_incubating=self.webpackChunkapache_teaclave_incubating||[]).push([[9211],{6159:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"teaclave-sgx-sdk/documents/use-vscode---rls---rust-analysis---sgx-gdb-for-graphic-developing-(not-in-docker)","title":"use-vscode---rls---rust-analysis---sgx-gdb-for-graphic-developing-(not-in-docker)","description":"This is my personal setup and contains some IP/path/usernames. Please tweak them in your environment.","source":"@site/docs/teaclave-sgx-sdk/documents/use-vscode---rls---rust-analysis---sgx-gdb-for-graphic-developing-(not-in-docker).md","sourceDirName":"teaclave-sgx-sdk/documents","slug":"/sgx-sdk-docs/use-vscode-rls","permalink":"/sgx-sdk-docs/use-vscode-rls","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"permalink":"/sgx-sdk-docs/use-vscode-rls","slug":"/sgx-sdk-docs/use-vscode-rls"}}');var i=n(4848),o=n(8453);const r={permalink:"/sgx-sdk-docs/use-vscode-rls",slug:"/sgx-sdk-docs/use-vscode-rls"},d="Solution overview",c={},l=[{value:"Setup the vscode-ssh session.",id:"setup-the-vscode-ssh-session",level:2},{value:"Create an rls-friendly rust-sgx project.",id:"create-an-rls-friendly-rust-sgx-project",level:2},{value:"Setup Native Debug with sgx-gdb",id:"setup-native-debug-with-sgx-gdb",level:2}];function a(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.p,{children:"This is my personal setup and contains some IP/path/usernames. Please tweak them in your environment."}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.img,{src:"https://dingelish.com/vscode-dev.png",alt:"Finally"})}),"\n",(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"solution-overview",children:"Solution overview"})}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["Use Visual Code Insider and the ",(0,i.jsx)(s.a,{href:"https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh",children:"Remote - SSH"})," plugin to establish a vscode-ssh session."]}),"\n",(0,i.jsxs)(s.li,{children:["Tweak a project with a new ",(0,i.jsx)(s.code,{children:"Cargo.toml"})," workspace and all ",(0,i.jsx)(s.code,{children:"Makefile"}),"s. This enables ",(0,i.jsx)(s.code,{children:"rls"}),"."]}),"\n",(0,i.jsx)(s.li,{children:"Tweak the build options for compiling in debug mode."}),"\n",(0,i.jsxs)(s.li,{children:["Use ",(0,i.jsx)(s.a,{href:"https://marketplace.visualstudio.com/items?itemName=webfreak.debug",children:"Native Debug"})," plugin for graphic debugging."]}),"\n"]}),"\n",(0,i.jsx)(s.h1,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Visual Code Insider installed on your machine. OS is flexible."}),"\n",(0,i.jsx)(s.li,{children:"Remote Linux supports Intel SGX, with SSH service started."}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"rustup"}),", Intel SGX driver/PSW/SDKs are correctly installed. ",(0,i.jsx)(s.code,{children:"hello-rust"})," code sample works."]}),"\n",(0,i.jsxs)(s.li,{children:["Remote Linux ",(0,i.jsx)(s.strong,{children:"could"})," be the same machine. Just ignore the ",(0,i.jsx)(s.code,{children:"vscode-ssh"})," plugin mentioned in this wiki page and you'll be fine."]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"My personal setup is:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Macbook. MacOS 10.14.4 + VSCode Insider."}),"\n",(0,i.jsx)(s.li,{children:"Remote desktop PC running Ubuntu Linux 18.04. Intel SGX v2.5."}),"\n"]}),"\n",(0,i.jsx)(s.h1,{id:"known-bugs",children:"Known bugs"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"sgx-gdb"})," throws Python exception on ",(0,i.jsx)(s.code,{children:"gdb"})," > 7.12 on some platforms, such as mine. But native sgx-gdb may not throw that error. Don't have a solution for VSCode yet. YMMV."]}),"\n"]}),"\n",(0,i.jsx)(s.h1,{id:"steps",children:"Steps"}),"\n",(0,i.jsx)(s.h2,{id:"setup-the-vscode-ssh-session",children:"Setup the vscode-ssh session."}),"\n",(0,i.jsxs)(s.ol,{start:"0",children:["\n",(0,i.jsxs)(s.li,{children:["Setup a convenient way for ssh login. I always append my ",(0,i.jsx)(s.code,{children:"~/.ssh/id_rsa.pub"})," to the remote ",(0,i.jsx)(s.code,{children:"~/.ssh/authorized_keys"}),"."]}),"\n",(0,i.jsxs)(s.li,{children:["Install the ",(0,i.jsx)(s.a,{href:"https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh",children:"Remote - SSH"})," plugin."]}),"\n",(0,i.jsx)(s.li,{children:"Establish a vscode-ssh session to the remote Linux."}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"create-an-rls-friendly-rust-sgx-project",children:"Create an rls-friendly rust-sgx project."}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.a,{href:"https://github.com/apache/incubator-teaclave-sgx-sdk/tree/master/samplecode/hello-rust-vscode-debug",children:"hello-rust-vscode-debug"})," is an example. Differences between this and ",(0,i.jsx)(s.code,{children:"hello-rust"})," are:"]}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["An extra ",(0,i.jsx)(s.code,{children:"Cargo.toml"})," at the root, which contains two Rust crates: ",(0,i.jsx)(s.code,{children:"app"})," and ",(0,i.jsx)(s.code,{children:"enclave"}),". This change would result in changing the path of ",(0,i.jsx)(s.code,{children:"target"})," folders."]}),"\n",(0,i.jsxs)(s.li,{children:["Tweak ",(0,i.jsx)(s.code,{children:"Makefile"})," and ",(0,i.jsx)(s.code,{children:"enclave/Makefile"})," and correct the path of ",(0,i.jsx)(s.code,{children:"target"})," folders."]}),"\n",(0,i.jsxs)(s.li,{children:["Tweak ",(0,i.jsx)(s.code,{children:"Makefile"})," and ",(0,i.jsx)(s.code,{children:"enclave/Makefile"})," to enable debug compilation. Changes include: (1) remove ",(0,i.jsx)(s.code,{children:"--release"})," in ",(0,i.jsx)(s.code,{children:"cargo build"}),", (2) add ",(0,i.jsx)(s.code,{children:"-ggdb"})," to ",(0,i.jsx)(s.code,{children:"SGX_COMMON_FLAGS"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:["After these steps, the ",(0,i.jsx)(s.code,{children:"hello-rust-vscode-debug"}),' should be an rls-friendly project. And open the remote folder of it in the VSCode main screen "Start - open folder". Then autocompletion should work!']}),"\n",(0,i.jsx)(s.h2,{id:"setup-native-debug-with-sgx-gdb",children:"Setup Native Debug with sgx-gdb"}),"\n",(0,i.jsxs)(s.p,{children:["Now we have a vscode-ssh session to the remote Linux and an opened folder of ",(0,i.jsx)(s.code,{children:"hello-rust-vscode-debug"}),". The next step is to configure a correct ",(0,i.jsx)(s.code,{children:"launch.json"})," for Native Debug plugin. Now open the debug panel of VS code and click on the gear icon to open ",(0,i.jsx)(s.code,{children:"launch.json"})," in the editor."]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{children:'{\n    // Use IntelliSense to learn about possible attributes.\n    // Hover to view descriptions of existing attributes.\n    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n    "version": "0.2.0",\n    "configurations": [\n        {\n            "name": "Debug",\n            "type": "gdb",\n            "request": "launch",\n            "target": "app",\n            "cwd": "${workspaceRoot}/bin",\n            "valuesFormatting": "parseText",\n            "gdbpath": "sgx-gdb",\n            "ssh": {\n                "forwardX11": false,\n                "host": "172.19.32.44", // your IP\n                "cwd": "${workspaceRoot}/bin",\n                 // SSH private key on remote machine. Add the pub key to ~/.ssh/authorized_keys\n                 // This ssh configuration is established from host to host, because the current\n                 // vscode session is "within a ssh session established by vscode-ssh".\n                 // I think this might be a bug but can hardly be resolved.\n                "keyfile": "/home/ding/.ssh/id_rsa", // private key\n                "user": "ding",\n                "bootstrap": "source /opt/sgxsdk/environment",\n                "port": 22\n            }\n        }\n    ]\n}\n'})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"name"}),",",(0,i.jsx)(s.code,{children:"type"}),",",(0,i.jsx)(s.code,{children:"request"}),",",(0,i.jsx)(s.code,{children:"valuesFormatting"})," are default values. ",(0,i.jsx)(s.code,{children:"cwd"})," is the working directory we launch the app, so it should be the ",(0,i.jsx)(s.code,{children:"bin"})," folder. ",(0,i.jsx)(s.code,{children:"target"})," is the debugee executable so it should be the ",(0,i.jsx)(s.code,{children:"app"}),". ",(0,i.jsx)(s.code,{children:"host"})," is the IP address of your Linux machine. Then comes the tricky part: ssh. It means that we use an extra ssh session for debugger, within the current vscode-ssh session. This means that we are here creating an additional ssh session from remote machine to itself. Only in this way could we setup the environment using the Intel's script before launching ",(0,i.jsx)(s.code,{children:"sgx-gdb"}),". So we need to add the public key ",(0,i.jsx)(s.code,{children:"~/.ssh/id_rsa"})," to ",(0,i.jsx)(s.code,{children:"~/.ssh/authorized_keys"})," and demonstrate the corresponding private key as ",(0,i.jsx)(s.code,{children:"~/.ssh/id_rsa"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["Having this ",(0,i.jsx)(s.code,{children:"launch.json"})," configured correctly, we could simply set up a breakpoint on the first line of ",(0,i.jsx)(s.code,{children:"say_something"})," and start debugging. Enjoy!"]})]})}function h(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>d});var t=n(6540);const i={},o=t.createContext(i);function r(e){const s=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function d(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(o.Provider,{value:s},e.children)}}}]);