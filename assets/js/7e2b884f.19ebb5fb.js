"use strict";(self.webpackChunkapache_teaclave_incubating=self.webpackChunkapache_teaclave_incubating||[]).push([[2337],{1184:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var s=t(4041);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}},7273:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"teaclave/docs/service-internals","title":"Teaclave Service Internals","description":"Teaclave Service is one of the most important abstractions in the platform.","source":"@site/docs/teaclave/docs/service-internals.md","sourceDirName":"teaclave/docs","slug":"/docs/service-internals","permalink":"/docs/service-internals","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"permalink":"/docs/service-internals","slug":"/docs/service-internals"},"sidebar":"teaclave_sidebar","previous":{"title":"Threat Model","permalink":"/docs/threat-model"},"next":{"title":"Adding Executors","permalink":"/docs/adding-executors"}}');var i=t(1085),r=t(1184);const a={permalink:"/docs/service-internals",slug:"/docs/service-internals"},c="Teaclave Service Internals",o={},l=[{value:"RPC and Protocols",id:"rpc-and-protocols",level:2},{value:"Service Implementation Structure",id:"service-implementation-structure",level:2},{value:"App (Untrusted)",id:"app-untrusted",level:3},{value:"Enclave (Trusted)",id:"enclave-trusted",level:3},{value:"Topology",id:"topology",level:2},{value:"Attestation in Services",id:"attestation-in-services",level:2},{value:"Customize a Standalone Service",id:"customize-a-standalone-service",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"teaclave-service-internals",children:"Teaclave Service Internals"})}),"\n",(0,i.jsx)(n.p,{children:"Teaclave Service is one of the most important abstractions in the platform.\nBasically, the Teaclave FaaS platform is the combination of different functional\nservices and connected through trusted channels. The Teaclave services include\nauthentication service, frontend service, management service, storage service,\naccess control service, scheduler service, and execution service. They play\ndifferent roles in the system."}),"\n",(0,i.jsx)(n.p,{children:"To understand the design and internal implementation of these services, we need\nto discuss in these sections: RPC and protocol, app-enclave structure, and\nthe attestation mechanism."}),"\n",(0,i.jsx)(n.h2,{id:"rpc-and-protocols",children:"RPC and Protocols"}),"\n",(0,i.jsx)(n.p,{children:"We use Protocol Buffers (version 3) to define messages and RPC interfaces of the\nTeaclave services. For example, the authentication service has this definition."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-proto",children:"message UserLoginRequest {\n  string id = 1;\n  string password = 2;\n}\n\nmessage UserLoginResponse {\n  string token = 1;\n}\n\nservice TeaclaveAuthenticationApi {\n  rpc UserLogin (UserLoginRequest) returns (UserLoginResponse);\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:['This means that the authentication service (for the API endpoint) has an RPC\ninterface called "',(0,i.jsx)(n.code,{children:"UserLogin"}),'", which takes a "',(0,i.jsx)(n.code,{children:"UserLoginRequest"}),'" message with\n',(0,i.jsx)(n.code,{children:"id"})," and ",(0,i.jsx)(n.code,{children:"password"}),' inside (in string type) and reply a "',(0,i.jsx)(n.code,{children:"UserLoginResponse"}),'"\nmessage with ',(0,i.jsx)(n.code,{children:"token"})," inside (in string type)."]}),"\n",(0,i.jsxs)(n.p,{children:["With this definition, the build system will help to generate utility functions,\ntraits, and structures for clients to send RPC requests, and for service to\nimplement functions of handling requests. This is done by ",(0,i.jsx)(n.a,{href:"https://github.com/hyperium/tonic/tree/master/tonic-build",children:(0,i.jsx)(n.code,{children:"tonic_build"})}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["For more protocol definitions for other services, please see proto files in\nthe ",(0,i.jsxs)(n.a,{href:"https://github.com/apache/incubator-teaclave/tree/master/services/proto/src/proto",children:[(0,i.jsx)(n.code,{children:"proto"})," directory"]}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"service-implementation-structure",children:"Service Implementation Structure"}),"\n",(0,i.jsx)(n.p,{children:"A service in Teaclave consists of two parts: the app (untrusted) part and the\nenclave (trusted) part. The app part is responsible for managing the service,\nlaunching and terminating the enclave part, while the enclave part is to serve\nRPC requests from clients (or other services) through trusted channels, execute\nlogic, and process data in the trusted execution environment."}),"\n",(0,i.jsx)(n.h3,{id:"app-untrusted",children:"App (Untrusted)"}),"\n",(0,i.jsx)(n.p,{children:"Basically, the app part of a service does the followings:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Load the runtime configuration from the config file."}),"\n",(0,i.jsx)(n.li,{children:"Create a service launcher: prepare the binder and set the serialized config as\nan input."}),"\n",(0,i.jsxs)(n.li,{children:["Start the service enclave (",(0,i.jsx)(n.em,{children:"ecall"})," to the trusted enclave part)."]}),"\n",(0,i.jsx)(n.li,{children:"Misc: register signal handlers so that the app/enclave can respond to some\nsignals."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"enclave-trusted",children:"Enclave (Trusted)"}),"\n",(0,i.jsx)(n.p,{children:"Typically, a service's implementation in the enclave part contains two important\nstructs and one trait. Let's take the frontend service as an example."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"TeaclaveFrontendService"})," (struct): Define properties or configurations along\nwith the lifetime of the service. For example, the frontend service needs to\nhold clients (with established trusted channels) to communicate with the\nauthentication service and management service."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"TeaclaveFrontendError"})," (struct): Define errors that may occur in this\nservice, authentication error, for example.\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"TeaclaveFrontend"})," (trait Define): functions (requests) the service needs to\nhandle. The trait will be automatically derived from definitions in the\nProtoBuf file and can be imported from the ",(0,i.jsx)(n.code,{children:"teaclave_proto"})," crate."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["You will see some ",(0,i.jsx)(n.code,{children:"#[handle_ecall]"})," annotations on functions and the\n",(0,i.jsx)(n.code,{children:"register_ecall_handler"})," macro to help with the function registration.\nThe lifecycle of a Teaclave service consists of enclave initialized, service\nstarted, and enclave finalized, which will invoke the corresponding command\nhandlers - ",(0,i.jsx)(n.code,{children:"InitEnclave"}),", ",(0,i.jsx)(n.code,{children:"StartService"}),", and ",(0,i.jsx)(n.code,{children:"FinalizeEnclave"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The start service function is the entry point of an enclave service. Here are\nsteps to prepare and start serving requests."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Initialize the attestation config and make a remote attestation."}),"\n",(0,i.jsx)(n.li,{children:"With the endorsed attestation report, initialize an attested TLS config."}),"\n",(0,i.jsx)(n.li,{children:"Initialize a TLS server with TLS config and listening address."}),"\n",(0,i.jsx)(n.li,{children:"If needed, initialize service endpoints this service wants to connect. For\nexample, the frontend service needs to connect to the authentication service\nand management service."}),"\n",(0,i.jsx)(n.li,{children:"Start the service (with endpoint handlers) and begin to serve requests."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Here is a code snippet from authentication service in the enclave part:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'let api_listen_address = config.api_endpoints.authentication.listen_address;\nlet attestation_config = AttestationConfig::from_teaclave_config(&config)?;\nlet attested_tls_config = RemoteAttestation::new(attestation_config)\n    .generate_and_endorse()?\n    .attested_tls_config()\n    .ok_or_else(|| anyhow!("cannot get attested TLS config"))?;\nlet server_config = SgxTrustedTlsServerConfig::from_attested_tls_config(attested_tls_config)?.into();\n\nlet service = api_service::TeaclaveAuthenticationApiService::new(db_client, jwt_secret);\n\nServer::builder()\n    .tls_config(tls_config)\n    .map_err(|_| anyhow!("TeaclaveAuthenticationApiServer tls config error"))?\n    .add_service(TeaclaveAuthenticationApiServer::new(service))\n    .serve(addr)\n    .await?;\n'})}),"\n",(0,i.jsx)(n.h2,{id:"topology",children:"Topology"}),"\n",(0,i.jsx)(n.p,{children:"These services are communicating through RPC with remote attestation. Here is a\ntopological graph illustrating connections between services."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"clients => authentication <-+       +----\x3e storage <----+\n                            |       |                   |\nclients => frontend ----------\x3e management            scheduler <-- execution\n             |                      |\n             +--\x3e access_control <--+\n\n\n                                                  =>      api endpoint connections\n                                                  -> internal endpoint connections\n"})}),"\n",(0,i.jsx)(n.h2,{id:"attestation-in-services",children:"Attestation in Services"}),"\n",(0,i.jsx)(n.p,{children:"To explain the usages of remote attestation mechanism in services, we need to\nconsider two different scenarios: 1) the service wants to serve RPC requests\nfrom clients, 2) the service wants to connect and send requests to other\nservices."}),"\n",(0,i.jsxs)(n.p,{children:["For the first scenario, the endorsed attestation report is used for creating the\ntrusted TLS server, so that clients can attest the service's report to verify\nthe platform. In the meantime, if the service wants to attest clients (a.k.a.,\nestablishing mutual attestation), we need to get the accepted enclave attributes\nfrom the ",(0,i.jsx)(n.em,{children:"enclave info"})," first to create the trusted TLS server. By this, the\nserver can also attest clients' attestation reports and only accept expected\nconnections."]}),"\n",(0,i.jsx)(n.p,{children:"You may find code like the following to get the accepted enclave attributes for\nmutual attestation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"let enclave_info = EnclaveInfo::verify_and_new(...)?;\nlet accepted_enclave_attrs: Vec<teaclave_types::EnclaveAttr> = AUTHENTICATION_INBOUND_SERVICES\n    .iter()\n    .map(|service| match enclave_info.get_enclave_attr(service) {...})\n    .collect::<Result<_>>()?;\n\n...\n\nlet server_config = SgxTrustedTlsServerConfig::from_attested_tls_config(attested_tls_config)?\n    .attestation_report_verifier(\n    accepted_enclave_attrs,\n    AS_ROOT_CA_CERT,\n    verifier::universal_quote_verifier,\n)?;\n"})}),"\n",(0,i.jsx)(n.p,{children:"For the second scenario, the report is used to create a trusted TLS channel so\nthat the client can present its report when establishing the channel. Also, the\nserver's report will be verified."}),"\n",(0,i.jsx)(n.h2,{id:"customize-a-standalone-service",children:"Customize a Standalone Service"}),"\n",(0,i.jsx)(n.p,{children:"For most cases, we suggest using the Teaclave platform as a whole for security\nand functionality concerns. However, you may want to customize a TEE service\nusing Teaclave's existing capabilities under our service framework. For\ninstance, the execution service can be used as a standalone TEE Python executor,\nand the storage service can be used as a secure database as well."}),"\n",(0,i.jsxs)(n.p,{children:["To customize Teaclave services as a standalone one, you need to first think\nabout the interfaces exposed to clients, that is the definitions in protobuf.\nFor example, for a key-value database, we have defined ",(0,i.jsx)(n.code,{children:"Get"}),", ",(0,i.jsx)(n.code,{children:"Put"})," and ",(0,i.jsx)(n.code,{children:"Delete"}),"\ninterfaces."]}),"\n",(0,i.jsx)(n.p,{children:'Additionally, if you are using it as a standalone TEE service, the attestation\nmechanism needs to be "one-way attestation" accordingly. That is, only clients\ncan establish trusted channels and attest the service\'s identity and platform\nstatus, but service cannot attest clients.'})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);