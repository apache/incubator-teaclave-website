"use strict";(self.webpackChunkapache_teaclave_incubating=self.webpackChunkapache_teaclave_incubating||[]).push([[4743],{2038:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"teaclave-sgx-sdk/documents/everything-about-cve-2020-5499","title":"Everything about CVE-2020-5499","description":"The Story","source":"@site/docs/teaclave-sgx-sdk/documents/everything-about-cve-2020-5499.md","sourceDirName":"teaclave-sgx-sdk/documents","slug":"/sgx-sdk-docs/everything-about-cve-2020-5499","permalink":"/sgx-sdk-docs/everything-about-cve-2020-5499","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"permalink":"/sgx-sdk-docs/everything-about-cve-2020-5499","slug":"/sgx-sdk-docs/everything-about-cve-2020-5499"},"sidebar":"teaclave-sgx-sdk_sidebar","previous":{"title":"Acquiring Trusted Timestamp from Intel ME in SGX enclave","permalink":"/sgx-sdk-docs/sgxtime"},"next":{"title":"Mitigation of Intel SA 00219 in Rust-SGX","permalink":"/sgx-sdk-docs/mitigation-of-intel-sa-00219"}}');var s=t(4848),c=t(8453);const r={permalink:"/sgx-sdk-docs/everything-about-cve-2020-5499",slug:"/sgx-sdk-docs/everything-about-cve-2020-5499"},i="Everything about CVE-2020-5499",o={},l=[{value:"The Story",id:"the-story",level:2},{value:"Analysis and Fix",id:"analysis-and-fix",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,c.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"everything-about-cve-2020-5499",children:"Everything about CVE-2020-5499"})}),"\n",(0,s.jsx)(n.h2,{id:"the-story",children:"The Story"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-5499",children:"CVE-2020-5499"}),"\nreported an enclave ID racing problem. We received the report on Nov 1st, 2019\nand fixed it on Nov 5th, 2019 with commit\n",(0,s.jsx)(n.a,{href:"https://github.com/apache/incubator-teaclave-sgx-sdk/commit/f29f4e71896589908cd4b43ed70a623a81eda0e5",children:"f29f4e71896589908cd4b43ed70a623a81eda0e5"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"analysis-and-fix",children:"Analysis and Fix"}),"\n",(0,s.jsxs)(n.p,{children:['The global data "enclave ID" was designed to hold the eid of the enclave\ninstance, and to be used for later provided ',(0,s.jsx)(n.code,{children:"thread::spawn"})," feature. In v1.0.8,\nwe didn't have ",(0,s.jsx)(n.code,{children:"thread::spawn"}),". So the data racing is true, but it can hardly\nharm the enclave."]}),"\n",(0,s.jsx)(n.p,{children:"To be more clear, let's look at the patch:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-diff",children:'diff --git a/sgx_tstd/src/rt.rs b/sgx_tstd/src/rt.rs\nindex fcfd0a42..3f738a53 100644\n--- a/sgx_tstd/src/rt.rs\n+++ b/sgx_tstd/src/rt.rs\n@@ -36,6 +36,9 @@ use core::str;\n pub use crate::panicking::{begin_panic, begin_panic_fmt, update_panic_count};\n pub use crate::sys_common::at_exit;\n use crate::sys_common::cleanup;\n+use crate::sync::Once;\n+\n+static INIT: Once = Once::new();\n\n #[no_mangle]\n pub extern "C" fn t_global_exit_ecall() {\n@@ -43,13 +46,14 @@ pub extern "C" fn t_global_exit_ecall() {\n\n #[no_mangle]\n pub extern "C" fn t_global_init_ecall(id: u64, path: * const u8, len: usize) {\n-\n-    enclave::set_enclave_id(id as sgx_enclave_id_t);\n-    let s = unsafe {\n-        let str_slice = slice::from_raw_parts(path, len);\n-        str::from_utf8_unchecked(str_slice)\n-    };\n-    enclave::set_enclave_path(s);\n+    INIT.call_once(|| {\n+        enclave::set_enclave_id(id as sgx_enclave_id_t);\n+        let s = unsafe {\n+            let str_slice = slice::from_raw_parts(path, len);\n+            str::from_utf8_unchecked(str_slice)\n+        };\n+        enclave::set_enclave_path(s);\n+    });\n }\n\n global_dtors_object! {\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Basically, the initiation here should be an atomic operation. To be more safe,\nwe marked it as ",(0,s.jsx)(n.code,{children:"Once"}),", which means that it can only be triggered once."]}),"\n",(0,s.jsxs)(n.p,{children:["Overall, we think the threat is subtle. One of the necessary condition is that\nthe enclave should be started with an undocumented feature of urts:\n",(0,s.jsx)(n.code,{children:"global_init"}),". Also the enclave should depend on enclave ID on critical paths.\nIt's really rare."]})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>i});var a=t(6540);const s={},c=a.createContext(s);function r(e){const n=a.useContext(c);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),a.createElement(c.Provider,{value:n},e.children)}}}]);