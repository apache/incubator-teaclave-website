<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Blocks unless or until the current thread’s token is made available."><meta name="keywords" content="rust, rustlang, rust-lang, park"><title>park in sgx_tstd::thread - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../normalize.css"><link rel="stylesheet" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../ayu.css" disabled><link rel="stylesheet" href="../../dark.css" disabled><link rel="stylesheet" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../sgx_tstd/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../sgx_tstd/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><div class="sidebar-elems"><h2><a href="index.html">In sgx_tstd::thread</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Function <a href="../index.html">sgx_tstd</a>::<wbr><a href="index.html">thread</a>::<wbr><a class="fn" href="#">park</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../src/sgx_tstd/thread/mod.rs.html#959-967">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="item-decl"><pre class="rust fn"><code>pub fn park()</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Blocks unless or until the current thread’s token is made available.</p>
<p>A call to <code>park</code> does not guarantee that the thread will remain parked
forever, and callers should be prepared for this possibility. However,
it is guaranteed that this function will not panic (it may abort the
process if the implementation encounters some rare errors).</p>
<h2 id="park-and-unpark"><a href="#park-and-unpark">park and unpark</a></h2>
<p>Every thread is equipped with some basic low-level blocking support, via the
<a href="fn.park.html" title="park"><code>thread::park</code></a> function and <a href="struct.Thread.html#method.unpark"><code>thread::Thread::unpark</code></a>
method. <a href="fn.park.html" title="park"><code>park</code></a> blocks the current thread, which can then be resumed from
another thread by calling the <a href="struct.Thread.html#method.unpark"><code>unpark</code></a> method on the blocked thread’s
handle.</p>
<p>Conceptually, each <a href="struct.Thread.html" title="Thread"><code>Thread</code></a> handle has an associated token, which is
initially not present:</p>
<ul>
<li>
<p>The <a href="fn.park.html" title="park"><code>thread::park</code></a> function blocks the current thread unless or
until the token is available for its thread handle, at which point it
atomically consumes the token. It may also return <em>spuriously</em>, without
consuming the token. <a href="fn.park_timeout.html"><code>thread::park_timeout</code></a> does the same, but allows
specifying a maximum time to block the thread for.</p>
</li>
<li>
<p>The <a href="struct.Thread.html#method.unpark"><code>unpark</code></a> method on a <a href="struct.Thread.html" title="Thread"><code>Thread</code></a> atomically makes the token available
if it wasn’t already. Because the token is initially absent, <a href="struct.Thread.html#method.unpark"><code>unpark</code></a>
followed by <a href="fn.park.html" title="park"><code>park</code></a> will result in the second call returning immediately.</p>
</li>
</ul>
<p>In other words, each <a href="struct.Thread.html" title="Thread"><code>Thread</code></a> acts a bit like a spinlock that can be
locked and unlocked using <code>park</code> and <code>unpark</code>.</p>
<p>Notice that being unblocked does not imply any synchronization with someone
that unparked this thread, it could also be spurious.
For example, it would be a valid, but inefficient, implementation to make both <a href="fn.park.html" title="park"><code>park</code></a> and
<a href="struct.Thread.html#method.unpark"><code>unpark</code></a> return immediately without doing anything.</p>
<p>The API is typically used by acquiring a handle to the current thread,
placing that handle in a shared data structure so that other threads can
find it, and then <code>park</code>ing in a loop. When some desired condition is met, another
thread calls <a href="struct.Thread.html#method.unpark"><code>unpark</code></a> on the handle.</p>
<p>The motivation for this design is twofold:</p>
<ul>
<li>
<p>It avoids the need to allocate mutexes and condvars when building new
synchronization primitives; the threads already provide basic
blocking/signaling.</p>
</li>
<li>
<p>It can be implemented very efficiently on many platforms.</p>
</li>
</ul>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::thread;
<span class="kw">use </span>std::sync::{Arc, atomic::{Ordering, AtomicBool}};
<span class="kw">use </span>std::time::Duration;

<span class="kw">let </span>flag = Arc::new(AtomicBool::new(<span class="bool-val">false</span>));
<span class="kw">let </span>flag2 = Arc::clone(<span class="kw-2">&amp;</span>flag);

<span class="kw">let </span>parked_thread = thread::spawn(<span class="kw">move </span>|| {
    <span class="comment">// We want to wait until the flag is set. We *could* just spin, but using
    // park/unpark is more efficient.
    </span><span class="kw">while </span>!flag2.load(Ordering::Acquire) {
        <span class="macro">println!</span>(<span class="string">&quot;Parking thread&quot;</span>);
        thread::park();
        <span class="comment">// We *could* get here spuriously, i.e., way before the 10ms below are over!
        // But that is no problem, we are in a loop until the flag is set anyway.
        </span><span class="macro">println!</span>(<span class="string">&quot;Thread unparked&quot;</span>);
    }
    <span class="macro">println!</span>(<span class="string">&quot;Flag received&quot;</span>);
});

<span class="comment">// Let some time pass for the thread to be spawned.
</span>thread::sleep(Duration::from_millis(<span class="number">10</span>));

<span class="comment">// Set the flag, and let the thread wake up.
// There is no race condition here, if `unpark`
// happens first, `park` will return immediately.
// Hence there is no risk of a deadlock.
</span>flag.store(<span class="bool-val">true</span>, Ordering::Release);
<span class="macro">println!</span>(<span class="string">&quot;Unpark the thread&quot;</span>);
parked_thread.thread().unpark();

parked_thread.join().unwrap();</code></pre></div>
</div></details></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="sgx_tstd" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.0-nightly (5c8bff74b 2022-10-21)" ></div></body></html>